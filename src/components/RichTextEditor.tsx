import { useRef, useEffect, useState } from 'react';
import { Bold, Italic, List, ListOrdered, Link as LinkIcon, Sparkles, Check, RotateCcw, Eye, Code } from 'lucide-react';

interface RichTextEditorProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  showAiButton?: boolean;
  onAiGenerate?: () => void;
  showHelpLink?: boolean;
  onHelpClick?: () => void;
}

export function RichTextEditor({ value, onChange, placeholder, showAiButton = false, onAiGenerate, showHelpLink = false, onHelpClick }: RichTextEditorProps) {
  const editorRef = useRef<HTMLDivElement>(null);
  const codeEditorRef = useRef<HTMLTextAreaElement>(null);
  const isInternalUpdate = useRef(false);
  const lastValue = useRef(value);
  const debounceTimer = useRef<NodeJS.Timeout | null>(null);
  const [isThinking, setIsThinking] = useState(false);
  const [showActions, setShowActions] = useState(false);
  const [originalValue, setOriginalValue] = useState('');
  const [viewMode, setViewMode] = useState<'preview' | 'code'>('preview');
  const [hasSelection, setHasSelection] = useState(false);
  const [selectionRange, setSelectionRange] = useState<Range | null>(null);
  const [selectedText, setSelectedText] = useState<string>('');

  useEffect(() => {
    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
    };
  }, []);

  useEffect(() => {
    if (isInternalUpdate.current) {
      isInternalUpdate.current = false;
      return;
    }
    // Only update if the value changed from an external source
    if (value === lastValue.current) {
      return;
    }
    lastValue.current = value;
    if (viewMode === 'preview' && editorRef.current) {
      editorRef.current.innerHTML = value;
    } else if (viewMode === 'code' && codeEditorRef.current) {
      codeEditorRef.current.value = value;
    }
  }, [value, viewMode]);

  useEffect(() => {
    if (!editorRef.current) return;

    const handleMouseUp = () => {
      const selection = window.getSelection();
      const selectedText = selection?.toString() || '';
      setHasSelection(selectedText.trim().length > 0);
    };

    const editor = editorRef.current;
    editor.addEventListener('mouseup', handleMouseUp);
    editor.addEventListener('keyup', handleMouseUp);
    
    return () => {
      editor.removeEventListener('mouseup', handleMouseUp);
      editor.removeEventListener('keyup', handleMouseUp);
    };
  }, [viewMode]);

  const handleInput = () => {
    if (editorRef.current) {
      const newValue = editorRef.current.innerHTML;
      
      // Clear existing timer
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      
      // Set new timer to debounce the onChange call
      debounceTimer.current = setTimeout(() => {
        lastValue.current = newValue;
        onChange(newValue);
      }, 150);
    }
  };

  const handleCodeInput = () => {
    if (codeEditorRef.current) {
      const newValue = codeEditorRef.current.value;
      
      // Clear existing timer
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      
      // Set new timer to debounce the onChange call
      debounceTimer.current = setTimeout(() => {
        lastValue.current = newValue;
        onChange(newValue);
      }, 150);
    }
  };

  const execCommand = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    editorRef.current?.focus();
  };

  const insertLink = () => {
    const url = prompt('Enter URL:');
    if (url) {
      execCommand('createLink', url);
    }
  };

  const handleHelpClick = () => {
    // Store original value for revert - get it from the editor itself
    const currentValue = editorRef.current?.innerHTML || '';
    setOriginalValue(currentValue);
    
    // Capture the current selection range and store it for later use
    const selection = window.getSelection();
    let capturedSelectedText = '';
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0).cloneRange();
      const selectedContent = selection.toString();
      setSelectionRange(range);
      setSelectedText(selectedContent);
      capturedSelectedText = selectedContent;
    }
    
    // Start thinking state
    setIsThinking(true);
    
    // Call the parent's onHelpClick if provided
    if (onHelpClick) {
      onHelpClick();
    }
    
    // Simulate AI generation after 3 seconds
    setTimeout(() => {
      const mockGeneratedText = 'Lorem ipsum generated by AI.';
      
      if (!editorRef.current) return;
      
      // Reset editor to original value first
      editorRef.current.innerHTML = currentValue;
      
      // Apply styling to the generated text
      const styledSpan = document.createElement('span');
      styledSpan.style.cssText = 'text-decoration: underline; text-decoration-color: rgba(139, 92, 246, 0.5); text-underline-offset: 2px; background-color: rgba(139, 92, 246, 0.1); padding: 2px 4px; border-radius: 2px;';
      styledSpan.textContent = mockGeneratedText;
      
      if (capturedSelectedText) {
        // Get the selected HTML content from the range
        const selectedContent = capturedSelectedText;
        
        // Create the styled HTML for the AI-generated text
        const styledHTML = `<span style="text-decoration: underline; text-decoration-color: rgba(139, 92, 246, 0.5); text-underline-offset: 2px; background-color: rgba(139, 92, 246, 0.1); padding: 2px 4px; border-radius: 2px;">${mockGeneratedText}</span>`;
        
        // Replace the selected text in the original value with the AI-generated text
        const modifiedValue = currentValue.replace(selectedContent, styledHTML);
        
        // Update the editor with the modified value
        editorRef.current.innerHTML = modifiedValue;
      } else {
        // If no selection, replace entire content
        editorRef.current.innerHTML = '<p><span style="text-decoration: underline; text-decoration-color: rgba(139, 92, 246, 0.5); text-underline-offset: 2px; background-color: rgba(139, 92, 246, 0.1); padding: 2px 4px; border-radius: 2px;">' + mockGeneratedText + '</span></p>';
      }
      
      // Update the value with the new content
      const newValue = editorRef.current.innerHTML;
      lastValue.current = newValue;
      isInternalUpdate.current = true;
      onChange(newValue);
      
      setIsThinking(false);
      setShowActions(true);
    }, 1000);
  };

  const handleValidate = () => {
    // Remove the styling wrapper from the span elements
    if (editorRef.current) {
      const spans = editorRef.current.querySelectorAll('span[style*="text-decoration: underline"]');
      spans.forEach(span => {
        const textNode = document.createTextNode(span.textContent || '');
        span.parentNode?.replaceChild(textNode, span);
      });
      const newValue = editorRef.current.innerHTML;
      lastValue.current = newValue;
      onChange(newValue);
    }
    setShowActions(false);
    setOriginalValue('');
    setSelectionRange(null);
    setSelectedText('');
  };

  const handleRevert = () => {
    // Revert to original value
    if (editorRef.current) {
      editorRef.current.innerHTML = originalValue;
    }
    lastValue.current = originalValue;
    onChange(originalValue);
    setShowActions(false);
    setOriginalValue('');
    setSelectionRange(null);
    setSelectedText('');
  };

  const isEmpty = !value || value.trim() === '' || value === '<br>';

  return (
    <div className="border border-gray-300 rounded bg-white">
      {/* Toolbar */}
      <div className="flex items-center gap-1 p-2 border-b border-gray-200 bg-gray-50">
        <button
          type="button"
          onClick={() => execCommand('bold')}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Bold"
        >
          <Bold className="w-4 h-4 text-gray-700" />
        </button>
        <button
          type="button"
          onClick={() => execCommand('italic')}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Italic"
        >
          <Italic className="w-4 h-4 text-gray-700" />
        </button>
        <div className="w-px h-6 bg-gray-300 mx-1" />
        <button
          type="button"
          onClick={() => execCommand('insertUnorderedList')}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Bullet List"
        >
          <List className="w-4 h-4 text-gray-700" />
        </button>
        <button
          type="button"
          onClick={() => execCommand('insertOrderedList')}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Numbered List"
        >
          <ListOrdered className="w-4 h-4 text-gray-700" />
        </button>
        <div className="w-px h-6 bg-gray-300 mx-1" />
        <button
          type="button"
          onClick={insertLink}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Insert Link"
        >
          <LinkIcon className="w-4 h-4 text-gray-700" />
        </button>
        <div className="w-px h-6 bg-gray-300 mx-1" />
        <button
          type="button"
          onClick={() => setViewMode(viewMode === 'preview' ? 'code' : 'preview')}
          className="p-2 hover:bg-gray-200 rounded transition-colors"
          title="Toggle View Mode"
        >
          {viewMode === 'preview' ? <Code className="w-4 h-4 text-gray-700" /> : <Eye className="w-4 h-4 text-gray-700" />}
        </button>
      </div>

      {/* Editor with Help Link */}
      <div className="relative">
        {viewMode === 'preview' && (
          <div
            ref={editorRef}
            contentEditable
            onInput={handleInput}
            className="px-4 pt-3 pb-14 min-h-[120px] outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset"
            data-placeholder={placeholder}
            style={{
              whiteSpace: 'pre-wrap',
              wordWrap: 'break-word'
            }}
          />
        )}
        {viewMode === 'code' && (
          <textarea
            ref={codeEditorRef}
            onInput={handleCodeInput}
            className="w-full px-4 py-3 min-h-[120px] outline-none focus:ring-2 focus:ring-blue-500 focus:ring-inset font-mono text-sm"
            placeholder={placeholder}
            style={{
              whiteSpace: 'pre-wrap',
              wordWrap: 'break-word',
              resize: 'vertical'
            }}
          />
        )}
        {showHelpLink && onHelpClick && !isThinking && !showActions && (
          <button
            type="button"
            onClick={handleHelpClick}
            className="hover:cursor-pointer absolute left-4 bottom-3 transition-opacity hover:opacity-80 flex items-center gap-1.5 text-sm underline"
            style={{ 
              pointerEvents: 'auto',
              background: 'linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              backgroundClip: 'text'
            }}
          >
            <Sparkles className="w-3.5 h-3.5 " style={{ color: '#8b5cf6' }} />
            {hasSelection ? 'Improve the text selection' : 'Help me generate or improve a description'}
          </button>
        )}
        {isThinking && (
          <div className="absolute left-4 bottom-3 flex items-center gap-1.5 text-sm">
            <Sparkles 
              className="w-3.5 h-3.5 animate-spin" 
              style={{ color: '#8b5cf6' }} 
            />
            <span
              style={{ 
                background: 'linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%)',
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                backgroundClip: 'text'
              }}
            >
              Thinking...
            </span>
          </div>
        )}
        {showActions && (
          <div className="absolute left-4 bottom-3 flex items-center gap-2">
            <button
              type="button"
              onClick={handleValidate}
              className="px-3 py-1.5 bg-green-500 hover:bg-green-600 text-white rounded transition-colors flex items-center gap-1.5 text-sm"
              title="Validate"
            >
              <Check className="w-3.5 h-3.5" />
              Validate
            </button>
            <button
              type="button"
              onClick={handleRevert}
              className="px-3 py-1.5 bg-red-500 hover:bg-red-600 text-white rounded transition-colors flex items-center gap-1.5 text-sm"
              title="Revert"
            >
              <RotateCcw className="w-3.5 h-3.5" />
              Revert
            </button>
          </div>
        )}
      </div>
    </div>
  );
}